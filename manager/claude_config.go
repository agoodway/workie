package manager

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/agoodway/workie/ai"
	"github.com/agoodway/workie/config"
)

// ClaudeConfigWrapper wraps the hooks config with optional comment
type ClaudeConfigWrapper struct {
	Comment string                       `json:"_comment,omitempty"`
	Hooks   map[string][]ClaudeHookEntry `json:"hooks"`
}

// ClaudeHooksConfig represents the Claude Code hooks configuration structure
type ClaudeHooksConfig struct {
	Hooks map[string][]ClaudeHookEntry `json:"hooks"`
}

// ClaudeHookEntry represents a single hook configuration entry
type ClaudeHookEntry struct {
	Matcher string                 `json:"matcher,omitempty"`
	Hooks   []ClaudeHookDefinition `json:"hooks"`
}

// ClaudeHookDefinition represents the actual hook command
type ClaudeHookDefinition struct {
	Type    string `json:"type"`
	Command string `json:"command"`
}

// Hook type mapping from Workie to Claude Code
var hookTypeMapping = map[string]string{
	"claude_pre_tool_use":       "PreToolUse",
	"claude_post_tool_use":      "PostToolUse",
	"claude_notification":       "Notification",
	"claude_user_prompt_submit": "UserPromptSubmit",
	"claude_stop":               "Stop",
	"claude_subagent_stop":      "SubagentStop",
	"claude_pre_compact":        "PreCompact",
}

// GenerateClaudeConfig generates Claude Code settings configuration
func (wm *WorktreeManager) GenerateClaudeConfig(selectedHooks []string, useAI bool) (string, error) {
	// Determine which hooks to include
	hooksToInclude := make(map[string]bool)

	if len(selectedHooks) == 0 {
		// Include all available hooks
		for hook := range hookTypeMapping {
			hooksToInclude[hook] = true
		}
	} else {
		// Include only selected hooks
		for _, hook := range selectedHooks {
			// Normalize hook name
			normalizedHook := normalizeHookName(hook)
			if _, exists := hookTypeMapping[normalizedHook]; exists {
				hooksToInclude[normalizedHook] = true
			}
		}
	}

	// Build the configuration
	config := ClaudeHooksConfig{
		Hooks: make(map[string][]ClaudeHookEntry),
	}

	// Add hooks based on what's configured in workie
	for workieHook, claudeHook := range hookTypeMapping {
		if !hooksToInclude[workieHook] {
			continue
		}

		// Check if this hook is configured in workie
		if wm.Config != nil && wm.Config.Hooks != nil && hasHookConfigured(wm.Config.Hooks, workieHook) {
			entry := ClaudeHookEntry{
				Hooks: []ClaudeHookDefinition{
					{
						Type:    "command",
						Command: fmt.Sprintf("workie hooks run %s", wm.normalizeForCommand(workieHook)),
					},
				},
			}

			// Add matcher for specific hooks
			if claudeHook == "PreToolUse" || claudeHook == "PostToolUse" {
				// For tool-specific hooks, add a matcher for common tools
				if useAI {
					matcher, err := wm.generateMatcherWithAI(workieHook)
					if err == nil && matcher != "" {
						entry.Matcher = matcher
					}
				} else {
					// Default matchers based on common use cases
					if claudeHook == "PreToolUse" {
						// Security-focused: monitor tools that can modify system or execute commands
						entry.Matcher = "Bash|Write|Edit|MultiEdit"
					} else if claudeHook == "PostToolUse" {
						// Post-processing: monitor tools that modify files
						entry.Matcher = "Edit|MultiEdit|Write"
					}
				}
			}

			config.Hooks[claudeHook] = []ClaudeHookEntry{entry}
		}
	}

	// If AI is enabled, enhance the configuration
	if useAI && wm.Config != nil && wm.Config.IsAIEnabled() {
		enhancedConfig, err := wm.enhanceConfigWithAI(config)
		if err == nil {
			config = enhancedConfig
		}
	}

	// Create wrapper with helpful comment
	wrapper := ClaudeConfigWrapper{
		Comment: "Generated by Workie. Add this to your Claude Code settings.json file. See: https://docs.anthropic.com/en/docs/claude-code/hooks",
		Hooks:   config.Hooks,
	}

	// Marshal to JSON with proper formatting
	jsonBytes, err := json.MarshalIndent(wrapper, "", "  ")
	if err != nil {
		return "", fmt.Errorf("failed to marshal config: %w", err)
	}

	return string(jsonBytes), nil
}

// normalizeHookName converts various hook name formats to the canonical form
func normalizeHookName(hook string) string {
	hook = strings.ToLower(hook)
	hook = strings.ReplaceAll(hook, "-", "_")

	// Handle shortened names
	shortcuts := map[string]string{
		"pre_tool_use":       "claude_pre_tool_use",
		"post_tool_use":      "claude_post_tool_use",
		"notification":       "claude_notification",
		"user_prompt_submit": "claude_user_prompt_submit",
		"stop":               "claude_stop",
		"subagent_stop":      "claude_subagent_stop",
		"pre_compact":        "claude_pre_compact",
	}

	if full, exists := shortcuts[hook]; exists {
		return full
	}

	// Add claude_ prefix if missing
	if !strings.HasPrefix(hook, "claude_") {
		hook = "claude_" + hook
	}

	return hook
}

// normalizeForCommand converts hook name to command format
func (wm *WorktreeManager) normalizeForCommand(hook string) string {
	// Remove claude_ prefix for command
	return strings.TrimPrefix(hook, "claude_")
}

// hasHookConfigured checks if a specific hook type has any commands configured
func hasHookConfigured(hooks *config.Hooks, hookType string) bool {
	switch hookType {
	case "claude_pre_tool_use":
		return len(hooks.ClaudePreToolUse) > 0
	case "claude_post_tool_use":
		return len(hooks.ClaudePostToolUse) > 0
	case "claude_notification":
		return len(hooks.ClaudeNotification) > 0
	case "claude_user_prompt_submit":
		return len(hooks.ClaudeUserPromptSubmit) > 0
	case "claude_stop":
		return len(hooks.ClaudeStop) > 0
	case "claude_subagent_stop":
		return len(hooks.ClaudeSubagentStop) > 0
	case "claude_pre_compact":
		return len(hooks.ClaudePreCompact) > 0
	}
	return false
}

// generateMatcherWithAI uses AI to generate optimal matcher patterns
func (wm *WorktreeManager) generateMatcherWithAI(hookType string) (string, error) {
	if wm.Config == nil || !wm.Config.IsAIEnabled() {
		return "", nil
	}

	// Create AI service
	aiService, err := ai.NewService(wm.Config)
	if err != nil {
		return "", err
	}

	// Build prompt for matcher generation
	prompt := fmt.Sprintf(`Based on the configured hooks for %s, suggest an optimal tool matcher pattern for Claude Code.

Claude Code Hook Context:
- Matchers are case-sensitive and match tool names exactly
- Use pipe (|) to match multiple tools
- Empty matcher runs for all tool uses
- Common tools: Task, Bash, Glob, Grep, LS, Read, Edit, MultiEdit, Write, NotebookRead, NotebookEdit, WebFetch, TodoWrite, WebSearch

Hook Types:
- PreToolUse: Validate/modify before tool execution (commonly uses matchers)
- PostToolUse: Run after successful tool completion (commonly uses matchers)
- Other hooks (Stop, Notification, etc.) typically don't use matchers

Security Considerations:
- For PreToolUse: Include security-sensitive tools like Bash, Write, Edit
- For PostToolUse: Include tools that modify files like Edit, Write
- Consider performance impact of running hooks on frequently used tools

Based on hook type %s, suggest an appropriate matcher pattern.
Respond with ONLY the matcher pattern, nothing else.
Example: Write|Edit|Bash`, hookType, hookType)

	// Call AI
	ctx := context.Background()
	response, err := aiService.CallLLM(ctx, prompt)
	if err != nil {
		return "", err
	}

	// Clean up response
	matcher := strings.TrimSpace(response)
	matcher = strings.Trim(matcher, "`\"'")

	return matcher, nil
}

// enhanceConfigWithAI uses AI to enhance the configuration with optimal settings
func (wm *WorktreeManager) enhanceConfigWithAI(config ClaudeHooksConfig) (ClaudeHooksConfig, error) {
	if wm.Config == nil || !wm.Config.IsAIEnabled() {
		return config, nil
	}

	// Create AI service
	aiService, err := ai.NewService(wm.Config)
	if err != nil {
		return config, err
	}

	// Convert current config to JSON for context
	currentJSON, _ := json.MarshalIndent(config, "", "  ")

	// Build enhancement prompt
	prompt := fmt.Sprintf(`Review and enhance this Claude Code hooks configuration for optimal security and performance:

%s

Claude Code Hooks Documentation:
Hook Types:
- PreToolUse: Runs before tool execution, can block with exit code 2
- PostToolUse: Runs after successful tool completion
- Notification: Triggered during system notifications
- UserPromptSubmit: Runs when user submits a prompt
- Stop: Runs when main agent finishes responding
- SubagentStop: Runs when subagent completes
- PreCompact: Runs before context compaction

Configuration Rules:
- Matchers are case-sensitive tool names (e.g., Bash, Edit, Write)
- Use pipe (|) for multiple tools: "Write|Edit|Bash"
- Empty matcher runs for all events of that type
- Commands should use absolute paths when possible
- Exit code 0 = success, 2 = block execution, other = non-blocking error

Best Practices:
1. PreToolUse hooks should focus on security-critical tools (Bash, Write, Edit)
2. PostToolUse hooks are good for linting/formatting after Edit operations
3. Avoid heavy operations in frequently-triggered hooks
4. Use specific matchers to reduce performance impact
5. Quote shell variables properly in commands

Enhance the configuration considering:
1. Security without being overly restrictive
2. Performance by using specific matchers
3. Appropriate hooks for the configured commands
4. Proper command escaping and paths

Respond with ONLY the enhanced JSON configuration, nothing else.`, string(currentJSON))

	// Call AI
	ctx := context.Background()
	response, err := aiService.CallLLM(ctx, prompt)
	if err != nil {
		return config, err
	}

	// Parse enhanced config
	var enhancedConfig ClaudeHooksConfig
	response = strings.TrimSpace(response)

	// Extract JSON from response (handle markdown code blocks)
	if strings.Contains(response, "```json") {
		start := strings.Index(response, "```json") + 7
		end := strings.LastIndex(response, "```")
		if start < end {
			response = response[start:end]
		}
	} else if strings.Contains(response, "```") {
		start := strings.Index(response, "```") + 3
		end := strings.LastIndex(response, "```")
		if start < end {
			response = response[start:end]
		}
	}

	if err := json.Unmarshal([]byte(response), &enhancedConfig); err != nil {
		// If parsing fails, return original config
		return config, nil
	}

	return enhancedConfig, nil
}
